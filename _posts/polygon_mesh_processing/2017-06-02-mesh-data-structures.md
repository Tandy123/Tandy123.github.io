---
layout:     post
title:      "【数字几何处理】网格数据结构"
date:       2017-06-02 12:00:00
categories: polygon-mesh-processing
tags:  polygon-mesh-processing mesh data-stucture
author: Tandy
---

* content
{:toc}

这段时间重新翻开了《Polygon Mesh Process》，感觉有必要总结一些东西了，就从比较简单的数据结构开始吧




## 综述

几何建模的算法的效率和存储消耗很大程度上依赖于曲面网格的数据结构，这里简单介绍一些在文献当中最常见的数据结构。

选择一种好的网格数据结构需要考虑拓扑和算法两方面的因素：

- 拓扑需求。	需要通过数据结构来表示的是哪一种类型的网格？我们是否需要表示2-流形网格或者是复杂的边和独立的顶点？我们是只表示单纯的我那个或者我们需要去表示任意的多边形网格？网格是否是规则的或者是不规则的（regular, semi-regular, irregular）？我们是否需要构建一个不断细化的网格层次结构？以上都是基于拓扑需求需要考虑的问题。
- 算法需求。	我们需要在该数据结构中运用哪些算法？我们是想简单地渲染一个网格，或者是需要高效遍历顶点、边和面的邻域？网格是静态的或者是随时间变化的？我们是否需要将网格的点线面和额外的数据关联起来?考虑到存储消耗时，我们是否有特定的需求？以上都是基于算法需求需要考虑的问题。

评价一个数据结构需要测量各种标准，比如：（a）预处理是构建的时间，（b）进行一个特定查询的时间，（c）进行一个特定操作的时间和（d）内存消耗和冗余。针对一个特定的算法设计一个数据结构并不罕见，在几何处理中，有许多常见的数据结构，下面具体介绍：

## 基于面的数据结构

一个曲面最简答的表示方法就是存储一组多边形面片，这些面片用顶点进行表示。对于最简单的三角网格，每个面存储了三个顶点的位置，当使用32位单精度数字来表示点的坐标时，每个三角形需要3X3X4=36字节。由欧拉公式（V-E+F=2(1-g)）可知面的数量往往等于两倍的顶点数量，所以这种数据结构平均消耗72字节/顶点，因为它不能表示网格的连接，通常称为三角形汤（triangle soup）或多边形汤（polygon soup）。一些数据格式的文件，例如STL文件就是使用这种表示方法。

    上述存储空间推导过程，下面遇到类似的情况同理：
	设一共有n个顶点，则有2n个面
	每个面需要36字节，则总共需要36*2n字节
	对于每个顶点需要的存储空间为：36*2n/n=72字节/顶点

然而，这种表示方法在大部分应用中的效率并不高，不能显式地获取连接信息，同时顶点和相关的数据重复的次数等于每个顶点的度数。这些冗余可以通过引入索引面集合或者共享点的数据结构来得到避免，这种结构存储了一组顶点和并将多边形通过这组顶点的索引进行编码。对于三角网格的情况，我们使用32位来存储顶点坐标和面的索引，这种表示方法对于每个顶点需要12字节，对于每个面也是12字节，因此，总共消耗12字节/顶点+12字节/面=36字节/顶点，是上一种基于面的数据结构的一半。

![面集数据结构和索引面集数据结构][1]

由于这种表示方式简单并且在存储上高效，这种表示方法用在许多格式的文件中，例如OFF，OBJ和VRML。类似地，它与假定静态数据的一类有效渲染算法相关（OpenGL顶点数组）。

然而，由于没有额外的连接信息，这种数据结构在涉及到一个顶点的局部连接信息查询需要昂贵的代价，因此对于大多数算法来说，这种数据结构还是不够高效。

下面列举一些在大多数算法中频繁使用到的操作：

- 访问个别的顶点，边和面，包括以特定顺序枚举所有元素。
- 按一定方向遍历一个面的所有边，涉及到查找一个面的前向边和后向边。
- 访问一条边的相关面，根据不同的方向，这个面可以是左面也可以是右面，也可以访问相邻的面。
- 通过给定的一条边访问他的两个端点顶点。
- 给定一个顶点，可以访问到他的所有领域元素。

这些操作通过连接信息（和固定的方向）进行局部和全局的网格，和网格相关的点线面的遍历。

我们下面回顾几种为曲面网格的快速遍历设计的数据结构。

一种标准的基于面三角网格数据结构中，每个面存储三个顶点以及和他相关的三个相邻三角形的引用。每个顶点存储和它相邻的一个三角形的引用，如下图所示，基于这种连接信息，我们可以通过绕着一个顶点循环来枚举他的一环领域，并且实现上述的所有操作。这种方法被用在CGAL中的2维三角网格的表示，同时它只消耗了24字节/面+16字节/顶点=64字节/顶点的空间。

![存储在基于面的数据结构中的连接信息][2]

然而，这种数据结构也有一些缺陷，第一，他没有显式地存储边，所以没有数据可以访问到边。第二，枚举一环邻域时需要大量的判断（中心点是当前三角形的第1，第2或者第3顶点？），最后，如果这种数据结构备用在通常的多边形网格中，面的数据类型不再拥有固定的大小，这样将会使得实现变得更加复杂和低效。

## 基于边的数据结构

一般多边形网格的数据结构在逻辑上是基于边的，因为连接主要和网格的边相关。著名的基于边的数据结构有winged-edge和quad-edge。

winged-edge结构如下图所示，每个边存储他的端点，两个邻面和两个前向边两个后向边的引用。顶点中存储了它的一条邻边的引用。总之，他的存储消耗是16字节/顶点+32字节/边+4字节/面=120字节/顶点（根据欧拉公式，面的数量近似为顶点数量的2倍，边的数量近似为顶点数量的倍）。

![存储在基于边的数据结构中的连接信息][3]

虽然基于边的数据结构可以表示任意多边形网格，但是遍历一环邻域仍然需要进行判断（中心顶点是当前边的第一个点还是第二个点？）。这个问题最终通过半边数据结构可以得到解决，下面会具体介绍。

## 基于半边的数据结构

半边数据结构通过将一条边分成两有向条避免了基于边的数据结构中需要区分的问题，如下图所示，这种数据结构可以表示任意的多边形网格。

在半边数据结构中，半边的方向是沿着每个面或者边界的逆时针方向。这里每个边界都可以看成是空的面。

对于每个半边我们存储如下信息的引用：

- 它指向的顶点
- 他的邻面（如果是边界半边时为空）
- 面或者边界的下一条半边（沿着逆时针方向）
- 面的前一条半边
- 反向半边

注意到这个反向半边不是一定要存的，因为两条反向边总是成对地存在数组中，可以写成这样的形式：halfedges[i]和halfedges[i+1]，反向边可以通过模2隐式地得到。同时，我们可以用一对半边明确地表示所有的边。前向半边的引用也可以被忽略，因为它可以通过通过后向半边遍历得到。

![存储在半边数据结构中的连接信息][4]

此外，每个面存储一个半边的引用，每个顶点存储一个从它出发的半边的引用，这样半边的数量H大概是顶点数量的6倍，总的存储消耗时16字节/顶点+20字节/半边+4字节/面=144字节/顶点。如果不显式地存储前向半边和反向半边的话，存储消耗时96字节/顶点。

![半边数据结构遍历一环邻域][5]

一个半边可以让我们方便地遍历每个元素（顶点，边，半边，面）的所有环域元素。特别的，给定顶点的一环邻域可以在无区分的情况下枚举遍历。如上图所示，伪代码如下：

	void enumerate \ _one \ _ring ( VertexRef center , Function func )
	{
		HalfedgeRef h = outgoing \ _halfedge ( center );
		HalfedgeRef hstop = h;
		do {
			VertexRef v = vertex (h);
			func (v); // process vertex v
			h = next \ _halfedge ( opposite \ _halfedge (h) );
		} while (h != hstop );
	}

引用（HalfedgeRef）的接口可以通过使用指针或者索引来实现，在实际情况中，索引的表示更加灵活尽管内存的访问不是很直接。

## 有向边数据结构（Directed-Edge）

有向边数据结构是半边数据结构内存高效的一种变化类型，专门为三角网格设计的。它基于引用网格中每个元素（顶点，面或者半边）的索引。索引遵循某些隐含编码三角形网格一些连接信息的规则。不像之前成对的反向边，这种数据结构将属于一个面的三条半边组合起来。

准确地说，令f是面的索引，然后三条半边的索引如下形式给出：

	halfedge(f,i) = 3f + i, i = 0,1,2.

现在，令h作为半边的索引，然后，它的邻面的索引可以简单地用如下形式给出：

	face(h) = h/3, face_index(h) = h mod 3.

h的下一条半边的索引可以通过 (h + 1) mod 3 计算得到。剩余的连接都可以被显式地存储：每个顶点存储他的位置和从它出发的半边的索引；每个半边存储他的反向边和相邻顶点的索引。这样的内存消耗时16字节/顶点+8字节/半边=64字节/顶点，这样和基于面的数据结构的内存消耗一样，同时有向边数据结构还提供了许多功能。

我们这里描述的有向边数据结构单纯适用于三角网格或者纯四边形网格，主要的好处是他的空间效率，弊端是纯三角网格和纯四边形网格的限制，不能适用于两种情况的混合。同时他缺少对边的显示表示。

## 总结

设计数据结构是基于多边形网格的几何处理算法的核心。对于大多数算法我们推荐使用半边数据结构或者有向边数据结构，实现这样的数据结构通常在功能性，存储消耗，和计算效率上很难进行平衡，基于这样的情况，这里推荐使用一些已有的成熟的接口，例如CGAL，OpenMesh和MeshLab。


以上内容翻译自《Polygon Mesh Processing》第二章-Mesh Data Structure

[1]: {{ site.baseurl }}/images/201706/1.png "面集数据结构和索引面集数据结构"
[2]: {{ site.baseurl }}/images/201706/2.png "存储在基于面的数据结构中的连接信息"
[3]: {{ site.baseurl }}/images/201706/3.png "存储在基于边的数据结构中的连接信息"
[4]: {{ site.baseurl }}/images/201706/4.png "存储在半边数据结构中的连接信息"
[5]: {{ site.baseurl }}/images/201706/5.png "半边数据结构遍历一环邻域"



